(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*Clear[logFile,writeLog,showLog];*)
LogDateiName = DateString[{"Year","Month","Day","_","Hour","-","Minute"}]<>"_Logfile";
LogNotebook=CreateDocument["",NotebookFileName -> LogDateiName];
writeLog[message_]:=Module[{},
NotebookWrite[LogNotebook,Cell[BoxData[ToBoxes[message]], "Print"],None]
];
writeStatus[name_,fortschritt_,startzeit_,aktuelleZeit_]:=Module[{statusString},
statusString = ToString[name]<> " l\[ADoubleDot]uft. Fortschritt: "<>ToString[fortschritt]<> " %"<> "  Zeitbedarf:  "<> ToString[aktuelleZeit-startzeit]<>" Sekunden, d.h.  "<> ToString[Quotient[ Round[aktuelleZeit-aktuelleZeit],60]]<> " Minuten "<> ToString[Mod[Round[aktuelleZeit-startzeit],60]]<> " Sekunden.";
NotebookWrite[Cells[LogNotebook][[2]],Cell[BoxData[ToBoxes[statusString]],"Print"],None]
];
writeSubsection[subsection_]:=Module[{},
NotebookWrite[LogNotebook,Cell[subsection,"Subsection"],None]
];
writeSubsection["Status: "];
writeLog["Bild wird importiert."];
writeSubsection["Ausgabe der Verzeichnungskorrektur vom "<> DateString[{"Day",".","Month",".","Year"," um ","Hour",":","Minute"," Uhr"}]];
(*writeLog[message_String]:=Module[{str=OpenAppend[logFile[]],date=DateString[]},WriteString[str,StringJoin@@Riffle[{date,message,"\n"},"\t"]];
Close[str];]

showLog:=FilePrint@logFile@##&;
clearLog:=Module[{str=OpenWrite[logFile@##]},Close@str;]&*)

Initialisierung[TestBildLokal_, BildAnzeige_:0]:=
Module[{},
BildDaten=ImageData[TestBildLokal];
DimensionenBildDaten=Dimensions[BildDaten];
BildHoehe=Dimensions[BildDaten][[1]];
BildBreite=Dimensions[BildDaten][[2]];
BildZentrum={BildHoehe,BildBreite}/2+{0.5,0.5};
BildZentrumStandardKoord={BildZentrum[[2]]-0.5,BildHoehe-BildZentrum[[1]]+0.5};
HalbeBildDiagonalenLaenge=N[Sqrt[BildBreite^2+BildHoehe^2]/2];
If[BildAnzeige==1,writeLog[TestBildLokal]];
];

BildInformation[]:=
Module[{},
writeLog["BildHoehe: "<>ToString[ BildHoehe]];
writeLog["BildBreite: "<> ToString[BildBreite]];
writeLog["BildZentrum: "<> ToString[BildZentrum]];
writeLog["BildZentrumStandardKoordinaten: "<> ToString[BildZentrumStandardKoord]];
writeLog["L\[ADoubleDot]nge der halben Bilddiagonale: "<> ToString[N[HalbeBildDiagonalenLaenge]]];
];

BildKoordinatenZuStandardKoordinaten[BildKoordinatenTupel__]:=
Module[{StandardKoordinatenTupel},
StandardKoordinatenTupel={BildKoordinatenTupel[[2]]-0.5,BildHoehe-BildKoordinatenTupel[[1]]+0.5};
Return[StandardKoordinatenTupel];
];



(* Funktion: Verzerrt das Bild (Gr\[UDoubleDot]nkanal) anhand eines \[UDoubleDot]bergebenen Polynoms. *)
(* Ben\[ODoubleDot]tigt: Bild, "Verzerrungszentrum", Polynom (Variable x!), Normiertes Polynom (1\[Equal]Polynom normiert) *)
(* Liefert: Verzerrtes Graubild *)

BildKorrektur[Bild_,VZ_,PolynomFunktion_,Normierung_:1]:=Module[{StartZeitSchleife,GrauWerteMatrix, GrauWerteMatrixKorrigiert,i,j,t,NF,VF,Abstand,PunktVektorNorm,AbstandNeu,PunktNeu,a,a1,a2,b,b1,b2,Fl\[ADoubleDot]che1,Fl\[ADoubleDot]che2,Fl\[ADoubleDot]che3,Fl\[ADoubleDot]che4, Fortschritt},
(*writeLog["\nBeginn des Moduls BildKorrektur.\n"];*)
GrauWerteMatrix=ImageData[ColorSeparate[Bild,"Green"][[1]]];
GrauWerteMatrixKorrigiert=ConstantArray[0.,{BildHoehe,BildBreite}];
VF[t_]:=N[PolynomFunktion[t]];
(*writeLog["f(x)=",Polynom, " und f(5)=",VF[5]];*)
If[Normierung==1,NF=0.5*Sqrt[BildBreite^2+BildHoehe^2],NF=1];
StartZeitSchleife=TimeUsed[];
For[j=1,j<=BildHoehe,j++,
For[i=1,i<=BildBreite,i++,
Abstand=Norm[{i,j}-VZ];
If[Abstand==0,GrauWerteMatrixKorrigiert[[j,i]]=GrauWerteMatrix[[j,i]];Continue[];];
PunktVektorNorm=({i,j}-VZ)/Abstand;
AbstandNeu=VF[Abstand/NF]*NF;
PunktNeu=VZ+PunktVektorNorm*AbstandNeu;
If[PunktNeu[[1]]<1||PunktNeu[[2]]<1||PunktNeu[[1]]>= BildBreite||PunktNeu[[2]]>= BildHoehe,
GrauWerteMatrixKorrigiert[[j,i]]=0;
,
a=Floor[PunktNeu[[1]]];
a1=PunktNeu[[1]]-a;
a2=1-a1;
b=Floor[PunktNeu[[2]]];
b1=PunktNeu[[2]]-b;
b2=1-b1;
Fl\[ADoubleDot]che1=a2*b2;
Fl\[ADoubleDot]che2=a1*b2;
Fl\[ADoubleDot]che3=a1*b1;
Fl\[ADoubleDot]che4=a2*b1;
GrauWerteMatrixKorrigiert[[j,i]]=Fl\[ADoubleDot]che1*GrauWerteMatrix[[b,a]]+Fl\[ADoubleDot]che2*GrauWerteMatrix[[b,a+1]]+Fl\[ADoubleDot]che3*GrauWerteMatrix[[b+1,a+1]]+Fl\[ADoubleDot]che4*GrauWerteMatrix[[b+1,a]];
];
]; (* Ende For (i) *)
If[Mod[j,Round[BildHoehe/50]]== 0,
Fortschritt=N[100*j/BildHoehe,4];
writeStatus["BildKorrektur",Fortschritt,StartZeitSchleife, TimeUsed[]],
Null
]; (* End If *)
Clear[Fortschritt];

]; (* Ende For (j) *)

Return[  Image[GrauWerteMatrixKorrigiert] ];
]; (* Ende Module BildKorrektur *)

(* Funktion: Schachbretteckpunkte finden nach Verfahren Chen/Zhang. *)
(* Ben\[ODoubleDot]tigt: Bild, Korrekturfaktor ("%") *)
(* Liefert: Liste der gefundenen Eckpunkte *)
(* Ruft auf:  *)
FindPoints[Bild_,KF_:12]:=Module[{Punkte,PunkteFinal,PunkteTemp,Rx, Ry, Rxx, Ryy, Rxy,BildGauss, Matrix, GaussMatrix, GrauMatrix,GrauWerteBild,S,ErgebnisVonS,ErgebnisVonSTemp,AnzahlPunkte,KachelBreite,KachelHoehe,Fenster,FensterU,FensterO,FensterR,FensterL,LokalesMin,ThresholdMatrix,GlobalerThreshold,Rand,r,sig,i,j,s,t,x,y,aktuelleZeit, StartZeitFindPoints, Fortschritt, statusString},
StartZeitFindPoints=TimeUsed[];
Punkte={};
PunkteTemp={};
PunkteFinal={};
KachelBreite=160;
KachelHoehe=120;
Fenster=60;
Rand=30;

GrauWerteBild=ColorSeparate[Bild,"Green"][[1]];

BildGauss=ImageConvolve[GrauWerteBild,GaussianMatrix[{12,4},Method->"Gaussian"]]; (*Method Gaussian Bessel*)
GaussMatrix=ImageData[BildGauss];

r=1;
sig=1;

(*Differenzierung*)
Ry  = ImageData[ImageConvolve[Image[GaussMatrix], GaussianMatrix[{r, sig}, {1, 0},Method->"Gaussian"]]];Rx  = ImageData[ImageConvolve[Image[GaussMatrix], GaussianMatrix[{r, sig}, {0, 1},Method->"Gaussian"]]];Rxx = ImageData[ImageConvolve[Image[Rx], GaussianMatrix[{r, sig}, {0, 1},Method->"Gaussian"]]];
Ryy = ImageData[ImageConvolve[Image[Ry], GaussianMatrix[{r, sig}, {1, 0},Method->"Gaussian"]]];
Rxy = ImageData[ImageConvolve[Image[Rx], GaussianMatrix[{r, sig}, {1, 0},Method->"Gaussian"]]];


ErgebnisVonS=Rxx;
S[x_,y_]:=Rxx[[y,x]]*Ryy[[y,x]]-Rxy[[y,x]]*Rxy[[y,x]];

For[j=1,j<=BildHoehe,++j,
For[i=1,i<=BildBreite,++i,
ErgebnisVonS[[j,i]]=S[i,j];
];
If[Mod[j,100]== 99,
aktuelleZeit=TimeUsed[];
Fortschritt=N[j/BildHoehe*100/2,4];
writeStatus["FindPoints",Fortschritt,StartZeitFindPoints, TimeUsed[]],
Null
]; (* End If *)
Clear[Fortschritt];
];


ErgebnisVonSTemp=ErgebnisVonS;
(*ThresholdMatrix=AdaptiverSchwellwert[GrauWerteBild,KachelBreite,KachelHoehe];*)
GlobalerThreshold =Min[ErgebnisVonS]*KF/100;


For[y=1+Rand,y<= BildHoehe-Rand,++y,
For[x=1+Rand,x<= BildBreite-Rand,++x,
If[ErgebnisVonS[[y,x]]<= GlobalerThreshold(**ThresholdMatrix[[y,x]]*),
If[y<= Fenster,FensterU=y-1,FensterU=Fenster];
If[BildHoehe-y<= Fenster,FensterO=BildHoehe-y-1,FensterO=Fenster];
If[x<= Fenster,FensterL=x-1,FensterL=Fenster];
If[BildBreite-x<= Fenster,FensterR=BildBreite-x-1,FensterR=Fenster];

LokalesMin=Min[ErgebnisVonS[[y-FensterU;;y+FensterO,x-FensterL;;x+FensterR]]];
For[j=y-FensterU,j<=y+FensterO,++j,
For[i=x-FensterL,i<= x+FensterR,++i,
If[ErgebnisVonS[[j,i]]==LokalesMin,
AppendTo[Punkte,{i,j}];
];
];
];
ErgebnisVonS[[y-FensterU;;y+FensterO,x-FensterL;;x+FensterR]]=1;
];
];
If[Mod[y,100]== 99,
aktuelleZeit=TimeUsed[];
Fortschritt=N[y/(BildHoehe-Rand)*100/2 +50,4];
writeStatus["FindPoints",Fortschritt,StartZeitFindPoints, TimeUsed[]],
Null
]; (* End If *)
Clear[Fortschritt];
];

s[x_,y_]:=(Ry[[y,x]]*Rxy[[y,x]]-Rx[[y,x]]*Ryy[[y,x]])/(Rxx[[y,x]]*Ryy[[y,x]]-(Rxy[[y,x]])^2);
t[x_,y_]:=(Rx[[y,x]]*Rxy[[y,x]]-Ry[[y,x]]*Rxx[[y,x]])/(Rxx[[y,x]]*Ryy[[y,x]]-(Rxy[[y,x]])^2);

For[i=1,i<=Length[Punkte],++i,
x=Punkte[[i,1]];
y=Punkte[[i,2]];
AppendTo[PunkteFinal,{x+s[x,y],y+t[x,y]}];
];

Return[PunkteFinal];
];





(* Funktion: Anhand der gew\[UDoubleDot]nschten Punkteanzahl der Samplegr\[ODoubleDot]\[SZ]e und dem Verh\[ADoubleDot]ltnis des Samplefensters wird die Gr\[ODoubleDot]\[SZ]e des Samplefensters bestimmt. *)
(* Ben\[ODoubleDot]tigt: Gew\[UDoubleDot]nschte Anzahl der Samplepunkte, gew\[UDoubleDot]nschtes Seitenverh\[ADoubleDot]ltnis,Liste der gefundenen EckPunkte *)
(* Liefert: Das Suchfenster zur Bestimmung der Solldistanz*)
SampleSizing[SampleGroesse_,Ratio_,Punkte_]:=Module[{SuchFeld,PunkteFeld={},i,Suchfenster},
i=0;
While[Length[PunkteFeld]<SampleGroesse,
PunkteFeld=Select[Punkte,
#[[2]]<BildHoehe/2 +i &&
#[[2]]>BildHoehe/2 - i&& 
#[[1]]<BildBreite /2 +( Ratio[[2]]/Ratio[[1]])*i&& 
#[[1]]>BildBreite /2 -(Ratio[[2]]/Ratio[[1]])*i&
];
i++;
];
If[2*i<BildHoehe*0.15 ,
Suchfenster={BildHoehe*0.15,( Ratio[[2]]/Ratio[[1]])*BildHoehe*0.15};
,
If[2*i>BildHoehe*0.33,
Suchfenster={BildHoehe*0.25,( Ratio[[2]]/Ratio[[1]])*BildHoehe*0.25};
,
Suchfenster={i,( Ratio[[2]]/Ratio[[1]])*i};
];
];

Return[Suchfenster];
];

(* Funktion: Anhand der gew\[UDoubleDot]nschten Punkteanzahl der Samplegr\[ODoubleDot]\[SZ]e und dem Verh\[ADoubleDot]ltnis des Samplefensters wird die Gr\[ODoubleDot]\[SZ]e des Samplefensters um einen bestimmten Punkt bestimmt. *)
(* Ben\[ODoubleDot]tigt: Gew\[UDoubleDot]nschte Anzahl der Samplepunkte, gew\[UDoubleDot]nschtes Seitenverh\[ADoubleDot]ltnis,Liste der gefundenen EckPunkte, Ausgangspunkt *)
(* Liefert: Das Suchfenster zur Bestimmung der Solldistanz*)
SampleSizingPunkt[SampleGroesse_,Ratio_,Punkte_,StartPunkt_]:=Module[{SuchFeld,PunkteFeld={},i,Suchfenster},
i=0;
While[Length[PunkteFeld]<SampleGroesse,
PunkteFeld=Select[Punkte,
#[[2]]<StartPunkt[[2]] +i &&
#[[2]]>StartPunkt[[2]] - i&& 
#[[1]]<StartPunkt[[1]] +( Ratio[[2]]/Ratio[[1]])*i&& 
#[[1]]>StartPunkt[[1]]  -(Ratio[[2]]/Ratio[[1]])*i&
];
i++;
];
If[2*i<BildHoehe*0.25,
Suchfenster={BildHoehe*0.25,( Ratio[[2]]/Ratio[[1]])*BildHoehe*0.25};
,
Suchfenster={i,( Ratio[[2]]/Ratio[[1]])*i};
];
Return[Suchfenster];
];



(* Funktion: Referenzpunktebereich im Bild wird \[UDoubleDot]ber die angegebene H\[ODoubleDot]he und Breite um den gew\[ADoubleDot]hlten Punkt *)
(* Ben\[ODoubleDot]tigt: Gefundene Eckpunkte, Fensterh\[ODoubleDot]he, Fensterbreite *)
(* Liefert: Liste von Punkten im angegebenen Bereich*)
SamplePoints[Punkte_,FeldDimens_,StartPunkt_]:=Module[{PunkteFeld},
PunkteFeld=Select[Punkte,
#[[2]]<StartPunkt[[2]] +FeldDimens[[2]] &&
#[[2]]>StartPunkt[[2]] - FeldDimens[[2]]&& 
#[[1]]<StartPunkt[[1]] + FeldDimens[[1]]&& 
#[[1]]>StartPunkt[[1]] -FeldDimens[[1]]&
];
Return[PunkteFeld];
];

(* Funktion: Berechnet alle Abst\[ADoubleDot]nde aller Punkte zueinander *)
(* Ben\[ODoubleDot]tigt: Liste der gefundenen Eckpunkte *)
(* Liefert: Liste von Abst\[ADoubleDot]nden *)
AllDistances[Punkte_]:=Module[{Abstandsliste,i,j},
Abstandsliste={};
For[i=1,i<=  Length[Punkte],i++,
For[j=i+1,j<= Length[Punkte],j++,
Abstandsliste=AppendTo[Abstandsliste,Norm[Punkte[[i]]-Punkte[[j]]]];
];
];
Return[Abstandsliste];
];

(* Funktion: Findet \[UDoubleDot]ber jeden Punkt, der ein vollst\[ADoubleDot]ndiges Suchfenster aufspannen kann (Rand des Suchfensters darf nicht \[UDoubleDot]ber Bildrandwandern) *)
(* alle Punkte innerhalb dieses Fensters. Bildet dann f\[UDoubleDot]r jedes Fenster alle Abst\[ADoubleDot]nde der dort befindlichen Punkte und mittelt den Bereich mit der geringsten Standardabweichung. *)
(* Dieser Wert wird in jedem Fenster errechnet. Anschlie\[SZ]end wird der gemittelte Abstandsbereich gew\[ADoubleDot]hlt mit der geringsten SD wird gew\[ADoubleDot]hlt *)
(* Ben\[ODoubleDot]tigt: Liste der gefundenen Eckpunkte, Gr\[ODoubleDot]\[SZ]e des Suchfensters *)
(* Liefert: SollDistanz *)
AbstandsSuche[Punkte_,Dimensionen_,SampleGroesse_]:=Module[{SollDistanz,i,SampleTemp,AbstandTemp,InnenPunkte,Abstaende={},AbstaendeMean={}},
InnenPunkte=Select[Punkte,
#[[2]]<BildHoehe-Dimensionen[[2]]*1.1&&
#[[2]]>Dimensionen[[2]]*1.1&& 
#[[1]]<BildBreite -Dimensionen[[1]]*1.1&& 
#[[1]]>Dimensionen[[1]]*1.1&
];
For[i=1,i<= Length[InnenPunkte],i++,
SampleTemp=SamplePoints[Punkte,Dimensionen,InnenPunkte[[i]]];
AbstandTemp=AllDistances[SampleTemp];
If[Length[AbstandTemp]<=SampleGroesse/2,
AppendTo[AbstaendeMean,{{-1,-1},Min[AbstandTemp]}];
,
AppendTo[Abstaende,FlattenAt[{InnenPunkte[[i]],firstBin[AbstandTemp,Round[SampleGroesse/2]]},2]];
];
];
If[Length[Abstaende]>0,
SollDistanz=SortBy[Abstaende,Last][[All,{1,2}]]
,
SollDistanz=SortBy[AbstaendeMean,Last]
];
Return[SollDistanz];
];


(* Funktion: Sortiert die Liste aller Abst\[ADoubleDot]nde in aufsteigender Reihenfolge und nimmt an angebener Stelle eine angegebene Anzahl an benachbarten Werten heraus*)
(* Ben\[ODoubleDot]tigt: Liste aller Abst\[ADoubleDot]nde, Startstelle in der sortierten Liste, Anzahl der herauszunehmenden Werte*)
(* Liefert: Liste der gew\[ADoubleDot]hlten Abst\[ADoubleDot]nde *)
(* Wird aufgerufen von: StandardDevListe *)
StandardDevFenster[Abstaende_,Fensterbreite_,Startwert_]:=Take[Sort[Abstaende,Less],{1+Startwert,Fensterbreite+Startwert}];

(* Funktion: Erstellt Liste der Standardabweichungen aller Abst\[ADoubleDot]nde \[UDoubleDot]ber einen angegebenen Wert *)
(* Ben\[ODoubleDot]tigt: Liste aller Abst\[ADoubleDot]nde, Breite \[UDoubleDot]ber welche die Standardabweichung gebildet wird *)
(* Liefert: Liste der Standardabweichungen *)
(* Ruft auf: StandardDevFenster *)
StandardDevListe[Abstaende_,Fensterbreite_]:=Table[{n,StandardDeviation[StandardDevFenster[Abstaende,Fensterbreite,n]]},{n,1,Length[Abstaende]-Fensterbreite}];


(* Funktion: Berechnet f\[UDoubleDot]r eine Menge an zu sortierenden Abst\[ADoubleDot]nden die Standardabweichungen \[UDoubleDot]ber eine gegebene Samplegr\[ODoubleDot]\[SZ]e *)
(* und w\[ADoubleDot]hlt anhand der kleinsten Standardabweichung die beste Solldistanz (Mittelung der Werte innerhalb des besten SD-Samples) *)
(* Ben\[ODoubleDot]tigt: Liste aller Abst\[ADoubleDot]nde, Samplegr\[ODoubleDot]\[SZ]e *)
(* Liefert: die kleinste Standardabweichung mit gemittelter Solldistanz *)
(* Ruft auf: StandardDevFenster, StandardDevListe *)
(* Wird aufgerufen von: AbstandsSuche *)
firstBin[Abstaende_,SDFGroesse_]:=Module[{SDListe,MinSDListe,StartBin,BinMitSD},
SDListe=StandardDevListe[Abstaende,SDFGroesse];
MinSDListe=Select[SDListe,#[[2]]==Take[Sort[SDListe[[All,2]],Less],1][[1]]&][[1]];
StartBin=Mean[StandardDevFenster[Abstaende,SDFGroesse,MinSDListe[[1]]]];
BinMitSD={StartBin,MinSDListe[[2]]};
Return[BinMitSD];
];


(* Funktion: Berechnet den Dummy-Startwert, welcher der n\[ADoubleDot]chste Punkt zum Mittelpunkte ist *)
(* Ben\[ODoubleDot]tigt: die Liste aller Punkte / die Liste der Referenzpunkte *)
(* Liefert: Den Dummy-Startwert *)
FindStartPoint[Punkte_]:=Module[{AusgangsPunkt,FundPunkte,SuchKreis},
AusgangsPunkt={BildBreite/2,BildHoehe/2};
SuchKreis=0;
FundPunkte={};
While[Length[FundPunkte]==0,
FundPunkte=Select[Punkte,
#[[2]]<AusgangsPunkt[[2]] +SuchKreis &&
#[[2]]>AusgangsPunkt[[2]] - SuchKreis&& 
#[[1]]<AusgangsPunkt[[1]]+ SuchKreis&& 
#[[1]]>AusgangsPunkt[[1]] -SuchKreis&
];
SuchKreis++;
];
If[Length[FundPunkte]>1,
FundPunkte=FundPunkte[[1]];
];
Return[Flatten[FundPunkte]];

];

(* Funktion: Findet den Eckpunkt der dem Suchursprung am n\[ADoubleDot]chsten ist *)
(* Ben\[ODoubleDot]tigt: Suchausgangspunkt, Liste aller Punkte, Solldistanz *)
(* Liefert: den nahesten Eckpunkte *)
FindPoint[AusgangsPunkt_,Punkte_,SollDistanz_]:=Module[{FundPunkte,SuchKreis},
SuchKreis=0;
FundPunkte={};
While[Length[FundPunkte]==0 && SuchKreis <SollDistanz/5,
FundPunkte=Select[Punkte,
#[[2]]<AusgangsPunkt[[2]] +SuchKreis &&
#[[2]]>AusgangsPunkt[[2]] - SuchKreis&& 
#[[1]]<AusgangsPunkt[[1]]+ SuchKreis&& 
#[[1]]>AusgangsPunkt[[1]] -SuchKreis&
];
SuchKreis++;
];
If[Length[FundPunkte]==0,
FundPunkte=-1;
];

If[Length[FundPunkte]>1,
FundPunkte=FundPunkte[[1]];
];
If[Length[FundPunkte]>0,
FundPunkte=Flatten[FundPunkte];
];
Return[FundPunkte];

];

(* Funktion: Erstellt anhand der Solldistanz und der Drehung des Schachbretts das Sollgitter und versieht es mit Gitterkoordinaten. Ausgangspunkt ist ein gew\[ADoubleDot]hlter Eckpunkt. *)
(* Ben\[ODoubleDot]tigt: Startpunkt, SollDistanz, Liste der Ist-Punkte *)
(* Liefert: Sollgitter, Liste aus Bild und Gitterkoordinaten *)
TargetGrid[StartPunkt_,SollDistanz_,EckPunkte_]:=Module[{SollGitter={},HauptHorizontale={},j,m,MinEckPunkteX,MaxEckPunkteX,MinEckPunkteY,MaxEckPunkteY,AV,SV,RV,SVO,FitGerade,FitPunkte,x},
FitPunkte=Select[EckPunkte,#[[2,2]]==0&&-2<= #[[2,1]]<= 2&][[All,1]];
FitGerade=Fit[FitPunkte,{1,x},x];
(*AV={0,FitGerade[[1]]};*)
RV={1,(FitGerade[[2]]/x)};
SV=(RV/Norm[RV])*SollDistanz;
SVO={-SV[[2]],SV[[1]]};
MinEckPunkteX=Min[EckPunkte[[All,2,1]]];
MaxEckPunkteX=Max[EckPunkte[[All,2,1]]];
MinEckPunkteY=Min[EckPunkte[[All,2,2]]];
MaxEckPunkteY=Max[EckPunkte[[All,2,2]]];

For[j=MinEckPunkteX,j<=MaxEckPunkteX,++j,
For[m=MinEckPunkteY,m<= MaxEckPunkteY,++m,
SollGitter=AppendTo[SollGitter,{{j,m},StartPunkt+j*SV+m*SVO}];
];
];
Return[SollGitter];
];

(* Funktion: Indiziert alle gefundenen Punkte. Indiziert dabei zun\[ADoubleDot]chst die Horizontale die durch den Startpunkt l\[ADoubleDot]uft (am wenigsten verzeichnet) *)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, Startpunkt, initialen Startwert *)
(* Liefert: indizierte Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Ruft auf: IndizierungVertikale *)
(* Wird aufgerufen von: Indizierung *)
IndizierungH[Punkte_,StartPunkt_, StartSoll_]:=Module[{GitterKoord,Index,i,ii,j,jj,NextRechts, NextLinks,PunktGefunden,LetzterPunkt,Schrittweite},
Index={{{StartPunkt[[1]],StartPunkt[[2]]},{0,0}}};
Index=Join[Index,IndizierungVertikale[Punkte,{{StartPunkt[[1]],StartPunkt[[2]]},{0,0}},StartSoll]];
GitterKoord={};
PunktGefunden=StartPunkt;
Schrittweite=StartSoll;
NextLinks=StartPunkt-{StartSoll,0};
ii=-1;
For[i=StartPunkt[[1]],i> 0,i-=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextLinks,Punkte,Schrittweite];
If[TrueQ[PunktGefunden==  -1],
PunktGefunden=NextLinks;
,
AppendTo[Index,{PunktGefunden,{ii,0}}];
];
Index=Join[Index,IndizierungVertikale[Punkte,{PunktGefunden,{ii,0}},StartSoll]];
ii--;
NextLinks=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[1]]-LetzterPunkt[[1]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
jj=1;
NextRechts=StartPunkt+{StartSoll,0};
PunktGefunden=StartPunkt;
Schrittweite=StartSoll;
For[j=StartPunkt[[1]],j< BildBreite,j+=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextRechts,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextRechts;
,
AppendTo[Index,{PunktGefunden,{jj,0}}];
];
Index=Join[Index,IndizierungVertikale[Punkte,{PunktGefunden,{jj,0}},StartSoll]];
jj++;
NextRechts=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[1]]-LetzterPunkt[[1]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
Return[Index];
];

(* Funktion: Indiziert alle Punkte unter- und \[UDoubleDot]berhalb eines Punktes (auf der Horizontalen) *)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, Startpunkt (der Horizontalen), initialen Startwert *)
(* Liefert: indizierte Ist-Punkte, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Ruft auf: IndizierungVertikaleHoch, IndizierungVertikaleRunter *)
(* Wird aufgerufen von: IndizierungH *)
IndizierungVertikale[Punkte_,StartPunkt_,StartSoll_]:=Module[{i,IndexPunkte},
IndexPunkte={};
IndexPunkte=Join[IndexPunkte,IndizierungVertikaleHoch[Punkte,StartPunkt,StartSoll]];
IndexPunkte=Join[IndexPunkte,IndizierungVertikaleRunter[Punkte,StartPunkt,StartSoll]]; 
Return[IndexPunkte];
];

(* Funktion: Indiziert alle Punkte unterhalb eines Punktes der HauptHorizontalen*)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, ein Punkt der Horizontalen, initialen Startwert *)
(* Liefert: indizierte Vertikale, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Wird aufgerufen von: IndizierungVertikale *)
IndizierungVertikaleRunter[Punkte_,HorizontalPunkt_,StartSoll_]:=Module[{NextUnten,PunktGefunden,LetzterPunkt,Schrittweite,j,jj,VertikaleRunter},
jj=-1;
VertikaleRunter={};
NextUnten=HorizontalPunkt[[1]]-{0,StartSoll};
PunktGefunden=HorizontalPunkt[[1]];
Schrittweite=StartSoll;
For[j=HorizontalPunkt[[1,2]],j>0,j-=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextUnten,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextUnten;
,
AppendTo[VertikaleRunter,{PunktGefunden,{HorizontalPunkt[[2,1]],jj}}];
];
jj--;
NextUnten=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[2]]-LetzterPunkt[[2]]];
If[Schrittweite==0 ,Schrittweite=StartSoll];
];
Return[VertikaleRunter];
];

(* Funktion: Indiziert alle Punkte oberhalb eines Punktes der HauptHorizontalen*)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, ein Punkt der Horizontalen, initialen Startwert *)
(* Liefert: indizierte Vertikale, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Wird aufgerufen von: IndizierungVertikale *)
IndizierungVertikaleHoch[Punkte_,HorizontalPunkt_,StartSoll_]:=Module[{NextOben,PunktGefunden,LetzterPunkt,Schrittweite,j,jj,VertikaleHoch},
jj=1;
VertikaleHoch={};
NextOben=HorizontalPunkt[[1]]+{0,StartSoll};
PunktGefunden=HorizontalPunkt[[1]];
Schrittweite=StartSoll;
For[j=HorizontalPunkt[[1,2]],j< BildHoehe,j+=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextOben,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextOben;
,
AppendTo[VertikaleHoch,{PunktGefunden,{HorizontalPunkt[[2,1]],jj}}];
];
jj++;
NextOben=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[2]]-LetzterPunkt[[2]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
Return[VertikaleHoch];
];

(* Funktion: Indiziert alle gefundenen Punkte. Indiziert dabei zun\[ADoubleDot]chst die Vertikalen die durch den Startpunkt l\[ADoubleDot]uft (am wenigsten verzeichnet) *)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, Startpunkt, initialen Startwert *)
(* Liefert: indizierte Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Ruft auf: IndizierungHorizontale *)
(* Wird aufgerufen von: Indizierung *)
IndizierungV[Punkte_,StartPunkt_, StartSoll_]:=Module[{GitterKoord,Index,i,ii,j,jj,NextOben, NextUnten,PunktGefunden,LetzterPunkt,Schrittweite},
Index={{{StartPunkt[[1]],StartPunkt[[2]]},{0,0}}};
Index=Join[Index,IndizierungHorizontale[Punkte,{{StartPunkt[[1]],StartPunkt[[2]]},{0,0}},StartSoll]];
GitterKoord={};
PunktGefunden=StartPunkt;
Schrittweite=StartSoll;
NextUnten=StartPunkt-{0,StartSoll};
ii=-1;
For[i=StartPunkt[[2]],i> 0,i-=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextUnten,Punkte,Schrittweite];
If[TrueQ[PunktGefunden==  -1],
PunktGefunden=NextUnten;
,
AppendTo[Index,{PunktGefunden,{0,ii}}];
];
Index=Join[Index,IndizierungHorizontale[Punkte,{PunktGefunden,{0,ii}},StartSoll]];
ii--;
NextUnten=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[2]]-LetzterPunkt[[2]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
jj=1;
NextOben=StartPunkt+{0,StartSoll};
PunktGefunden=StartPunkt;
Schrittweite=StartSoll;
For[j=StartPunkt[[2]],j< BildHoehe,j+=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextOben,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextOben;
,
AppendTo[Index,{PunktGefunden,{0,jj}}];
];
Index=Join[Index,IndizierungHorizontale[Punkte,{PunktGefunden,{0,jj}},StartSoll]];
jj++;
NextOben=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[2]]-LetzterPunkt[[2]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
Return[Index];
];

(* Funktion: Indiziert alle Punkte rechts und links eines Punktes (auf der Vertikalen) *)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, Startpunkt (der Vertikalen), initialen Startwert *)
(* Liefert: indizierte Ist-Punkte, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Ruft auf: IndizierungVertikaleRechts, IndizierungVertikaleLinks *)
(* Wird aufgerufen von: IndizierungV *)
IndizierungHorizontale[Punkte_,StartPunkt_,StartSoll_]:=Module[{i,IndexPunkte},
IndexPunkte={};
IndexPunkte=Join[IndexPunkte,IndizierungHorizontaleRechts[Punkte,StartPunkt,StartSoll]];
IndexPunkte=Join[IndexPunkte,IndizierungHorizontaleLinks[Punkte,StartPunkt,StartSoll]];
Return[IndexPunkte];
];

(* Funktion: Indiziert alle Punkte links eines Punktes der HauptVertikalen*)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, ein Punkt der Horizontalen, initialen Startwert *)
(* Liefert: indizierte Horizontale, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Wird aufgerufen von: IndizierungVertikale *)
IndizierungHorizontaleLinks[Punkte_,HorizontalPunkt_,StartSoll_]:=Module[{NextLinks,PunktGefunden,LetzterPunkt,Schrittweite,j,jj,HorizontaleLinks},
jj=-1;
HorizontaleLinks={};
NextLinks=HorizontalPunkt[[1]]-{StartSoll,0};
PunktGefunden=HorizontalPunkt[[1]];
Schrittweite=StartSoll;
For[j=HorizontalPunkt[[1,1]],j>0,j-=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextLinks,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextLinks;
,
AppendTo[HorizontaleLinks,{PunktGefunden,{jj,HorizontalPunkt[[2,2]]}}];
];
jj--;
NextLinks=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[1]]-LetzterPunkt[[1]]];
If[Schrittweite==0 ,Schrittweite=StartSoll];
];
Return[HorizontaleLinks];
];

(* Funktion: Indiziert alle Punkte rechts eines Punktes der HauptVertikalen*)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, ein Punkt der Vertikalen, initialen Startwert *)
(* Liefert: indizierte Horizontale, Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Wird aufgerufen von: IndizierungVertikale *)
IndizierungHorizontaleRechts[Punkte_,HorizontalPunkt_,StartSoll_]:=Module[{NextRechts,PunktGefunden,LetzterPunkt,Schrittweite,j,jj,HorizontaleRechts},
jj=1;
HorizontaleRechts={};
NextRechts=HorizontalPunkt[[1]]+{StartSoll,0};
PunktGefunden=HorizontalPunkt[[1]];
Schrittweite=StartSoll;
For[j=HorizontalPunkt[[1,1]],j< BildBreite,j+=Schrittweite,
LetzterPunkt=PunktGefunden;
PunktGefunden=FindPoint[NextRechts,Punkte,Schrittweite];
If[TrueQ[PunktGefunden== -1],
PunktGefunden=NextRechts;
,
AppendTo[HorizontaleRechts,{PunktGefunden,{jj,HorizontalPunkt[[2,2]]}}];
];
jj++;
NextRechts=PunktGefunden+(PunktGefunden-LetzterPunkt);
Schrittweite=Abs[PunktGefunden[[1]]-LetzterPunkt[[1]]];
If[Schrittweite==0,Schrittweite=StartSoll];
];
Return[HorizontaleRechts];
];

(* Funktion: Entscheidet, ob \[UDoubleDot]ber die HauptHorizontale oder HauptVertikale indiziert wird *)
(* Ben\[ODoubleDot]tigt: Liste aller Punkte, Startpunkt, initialen Startwert *)
(* Liefert: indizierte Liste aus Bildkoordinaten und Gitterkoordinaten *)
(* Ruft auf: IndizierungV, IndizierungH *)
Indizierung[Punkte_,StartPunkt_, SollDistanz_]:=Module[{IndexH,IndexV,Index},
IndexH=IndizierungH[Punkte,StartPunkt, SollDistanz];
IndexV=IndizierungV[Punkte,StartPunkt, SollDistanz];
If[Length[IndexH]>Length[IndexV],
Index=IndexH;
,
Index=IndexV;
];
Return[Index];
];



(* Funktion: F\[UDoubleDot]gt die korrespondierenden Punkte der Ist- und Sollgitter zusammen, anhand der verteilten Gitterkoordinaten *)
(* Ben\[ODoubleDot]tigt: Soll- und Ist-Gitter *)
(* Liefert: zusammengef\[UDoubleDot]gte Liste aus Bildkoordinaten und Gitterkoordinaten der Soll und Ist-Punkte *)
IstSollGitter[SollGitter_, IstGitter_]:=Module[{SollIstListe,SollIstTemp,i},
SollIstListe={};
For[i=1,i<= Length[SollGitter],i++,
SollIstTemp=Select[IstGitter,#[[2]]==SollGitter[[i,1]] &];
If[SollIstTemp!= {},
SollIstListe=Join[SollIstListe,{{SollGitter[[i,2]],SollIstTemp[[1,1]],SollGitter[[i,1]]}}];
,Null];
];
Return[SollIstListe];
];

(* Funktion: Berechnet aus der Soll-Ist-Gitterliste die Soll und Istabst\[ADoubleDot]nde jedes Punktepaares zu einem gew\[ADoubleDot]hlten Startpunkt (Hauptpunkt) *)
(* Ben\[ODoubleDot]tigt: Soll-Ist-Gitter, StartPunkt *)
(* Liefert: zusammengef\[UDoubleDot]gte Liste aus Soll-, Ist-Abst\[ADoubleDot]nden und den Gitterkoordinaten *)
IstSollDistanzen[ISGitter_,StartPunkt_]:=Module[{i,j,AbstaendeSI},
AbstaendeSI={};
For[i=1,i<= Length[ISGitter],i++,
AbstaendeSI=AppendTo[AbstaendeSI,{Norm[ISGitter[[i,2]]-StartPunkt],Norm[ISGitter[[i,1]]-StartPunkt],ISGitter[[i,3]]}];
];
Return[AbstaendeSI];

];



(* Funktion: Berechnet aus den Indexpunkten die Standardabweichung aller direkter senkrechter und waagrechter Abst\[ADoubleDot]nde. *)
(* Ben\[ODoubleDot]tigt: Indexpunkte *)
(* Liefert: MStandardabweichung aller direkter senkrechter und waagrechter Abst\[ADoubleDot]nde *)
AequidistanzFehler[Index_]:=Module[{i,j,Abstaende,Punkt,PunktRechts,PunktUnten},
Abstaende={};
For[i=Min[Index[[All,2,1]]],i<=  Max[Index[[All,2,1]]],i++,
For[j=Min[Index[[All,2,2]]],j<=  Max[Index[[All,2,2]]],j++,
Punkt=Select[Index,#[[2,1]]==i && #[[2,2]]==j &];
If[i!= Max[Index[[All,2,1]]&&Length[Punkt]!=0 ],
PunktRechts=Select[Index,#[[2,1]]==i+1 && #[[2,2]]==j &];
If[Length[PunktRechts]!=0 ,
Abstaende=AppendTo[Abstaende,Norm[Punkt[[1]]-PunktRechts[[1]]]];
,Null];
,Null];
If[j!= Max[Index[[All,2,2]]&&Length[Punkt]!=0 ],
PunktUnten =Select[Index,#[[2,1]]==i && #[[2,2]]==j+1 &];
If[Length[PunktUnten]!=0 ,
Abstaende=AppendTo[Abstaende,Norm[Punkt[[1]]-PunktUnten[[1]]]];
,Null];
,Null];
];
];
(*
writeLog["Alle Abst\[ADoubleDot]nde: ",Abstaende];
writeLog["Durchschnittliche Abweichung: ",StandardDeviation[Abstaende]];
writeLog["Maximaler Abweichung:"];
*)
(*Max[Abstaende]-Min[Abstaende] *)
  Return[{StandardDeviation[Abstaende],Max[Abstaende]-Min[Abstaende] }];
];

(* Funktion: \[CapitalUDoubleDot]berpr\[UDoubleDot]ft die berechnete Solldistanz, anhand zweier Kriterien wird entschieden ob, die Solldistanz mit der niedrigsten Standardabweichung *)
(* tats\[ADoubleDot]chlich eine Direktverbindung zweier Punkte ist (keine Diagonalen) *)
(* Ben\[ODoubleDot]tigt: Punkte, SollDistanzen, Anzahl gew\[UDoubleDot]nschter Solldistanzen *)
(* Liefert: \[UDoubleDot]berpr\[UDoubleDot]fte Solldistanz *)
IterativeRefinementSollDistanz[SollDistanzenPunkt_,Anzahl_]:=Module[{IndexPunkte,SollDistanzen,i,Ueberschuss,Rand,TeilWerte,SollGitter,n,k,h,RefSoll,isRef},
SollDistanzen=SollDistanzenPunkt;

TeilWerte={2,3,4,5,6,Sqrt[2],Sqrt[5]};

RefSoll=Min[SollDistanzen[[All,2]]];
isRef=True;
For[h=1,h<=Length[SollDistanzen],h++,
For[i=h+1,i<=Length[SollDistanzen],i++,
For[n=1,n<Length[TeilWerte],n++,
If[SollDistanzen[[i,2]]>SollDistanzen[[h,2]]/TeilWerte[[n]] - (SollDistanzen[[h,2]]/TeilWerte[[n]])*0.15&& SollDistanzen[[i,2]]<SollDistanzen[[h,2]]/TeilWerte[[n]] + (SollDistanzen[[h,2]]/TeilWerte[[n]])*0.15,
isRef=False;

,Null];
];
];
If[isRef==True,
RefSoll=SollDistanzen[[h,2]];
Break[];,
isRef=True;
SollDistanzen =Delete[SollDistanzen,h];
--h;
];
];
For[k=1,k<=Anzahl,k++,
For[n=1,n<Length[TeilWerte],n++,
If[SollDistanzen[[k,2]]>RefSoll*TeilWerte[[n]] - (RefSoll*TeilWerte[[n]])*0.15&& SollDistanzen[[k,2]]<RefSoll*TeilWerte[[n]] + (RefSoll*TeilWerte[[n]])*0.15,
SollDistanzen =Delete[SollDistanzen,k];
--k;
,Null];
];
];
Return[Take[SollDistanzen,Anzahl]];
];

(* Funktion: L\[ODoubleDot]scht alle Abstaende die keine direkten Abstaende sind *)
(* Ben\[ODoubleDot]tigt: Abstaende *)
(* Liefert: bereinigte Solldistanzliste *)
IterativeRefinementSollDistanzEinzelPunkt[SollDistanzenPunkt_]:=Module[{IndexPunkte,SollDistanzen,i,Ueberschuss,Rand,TeilWerte,SollGitter,n,k,h,RefSoll,isRef},
SollDistanzen=SollDistanzenPunkt;

TeilWerte={2,3,4,5,6,Sqrt[2],Sqrt[5]};

RefSoll=Min[SollDistanzen];
isRef=True;
For[h=1,h<=Length[SollDistanzen],h++,
For[i=h+1,i<=Length[SollDistanzen],i++,
For[n=1,n<Length[TeilWerte],n++,
If[SollDistanzen[[i]]>SollDistanzen[[h]]/TeilWerte[[n]] - (SollDistanzen[[h]]/TeilWerte[[n]])*0.15&& SollDistanzen[[i]]<SollDistanzen[[h]]/TeilWerte[[n]] + (SollDistanzen[[h]]/TeilWerte[[n]])*0.15,
isRef=False;

,Null];
];
];
If[isRef==True,
RefSoll=SollDistanzen[[h]];
Break[];,
isRef=True;
SollDistanzen =Delete[SollDistanzen,h];
--h;
];
];
For[k=1,k<=Length[SollDistanzen],k++,
For[n=1,n<Length[TeilWerte],n++,
If[SollDistanzen[[k]]>RefSoll*TeilWerte[[n]] - (RefSoll*TeilWerte[[n]])*0.15&& SollDistanzen[[k]]<RefSoll*TeilWerte[[n]] + (RefSoll*TeilWerte[[n]])*0.15,
SollDistanzen =Delete[SollDistanzen,k];
--k;
,Null];
];
];
Return[SollDistanzen];
];


(* Funktion: Berechnet aus den Soll-Ist-Abstandspaaren das Verzeichnungspolynom, normiert und unnormiert, welches gleichzeitig das Korrekturpolynom f\[UDoubleDot]r den CRS Filter darstellt *)
(* Ben\[ODoubleDot]tigt: Soll-Ist-Abst\[ADoubleDot]nden *)
(* Liefert: 2 Polynome:  Verzeichnungspolynome (Korrekturpolynom f\[UDoubleDot]r Backward Warping), unnormiert und normiert *)
CalculatePolynom[SIAbstaende_]:=Module[{Daten, DatenNeu,(*PolynomialerAusdruck,PolynomFunktion,PolynomFunktionNormiert,*)Polynome},
Daten=SIAbstaende[[All,{2,1}]];
DatenNeu={#[[1]],#[[2]]-#[[1]]}&/@Daten;
Block[{t},
PolynomialerAusdruck=Fit[DatenNeu,{t^3,t^5,t^7},t]+t;
PolynomFunktion=Function[t,Evaluate[PolynomialerAusdruck] ];
];
(*Block[{r},
writeLog["Die Polynomfunktion zur Beschreibung der Verzeichnung ist gegegen durch V(r)= ",PolynomFunktion[r] ];
];
*)
PolynomFunktionNormiert=Function[t,Evaluate[Expand[N[(1/HalbeBildDiagonalenLaenge)*PolynomFunktion[HalbeBildDiagonalenLaenge*t]]]]];

(*Block[{\[Rho]},writeLog["Die normierte Polynomfunktion zur Beschreibung der Verzeichnung ist gegeben durch: ",PolynomFunktionNormiert[\[Rho]] ];
];
*)
(*Block[{r},writeLog["Verzeichnungspolynom, gleichzeitig Korrekturpolynom f\[UDoubleDot]r Backward Warping: ",PolynomFunktion[r]];
];
Block[{\[Rho]},
writeLog["Normiertes Verzeichnungspolynom, gleichzeitig normiertes Korrekturpolynom f\[UDoubleDot]r Backward Warping: ",PolynomFunktionNormiert[\[Rho]]];
];
*)
Polynome={PolynomFunktion,PolynomFunktionNormiert};
Return[Polynome];
];

(* Funktion: Berechnet aus den Soll-Ist-Abstandspaaren das Korrekturpolynom, normiert und unnormiert*)
(* Ben\[ODoubleDot]tigt: Soll-Ist-Abst\[ADoubleDot]nden *)
(* Liefert: 2 Polynome:  Korrekturpolynome, normiert und unnormiert *)
CalculateInversePolynom[SIAbstaende_]:=Module[{Daten, DatenNeu,PolynomFunktion,Poly,Polynom,PolyNorm,PolynomNorm,Polynome},
(*Poly=Fit[SIAbstaende[[All,{1,2}]],{t,t^2,t^3,t^4},t];*)
Daten=SIAbstaende[[All,{1,2}]];
DatenNeu={#[[1]],#[[2]]-#[[1]]}&/@Daten;
(*Poly=Fit[DatenNeu,{t^2,t^3,t^4},t]+t;
Polynom[x_]:=Poly/.t\[Rule] x;
PolynomFunktion:=Function[t,Poly];
PolynomNorm[x_]:=N[(1/HalbeBildDiagonalenLaenge)*PolynomFunktion[HalbeBildDiagonalenLaenge*t]]/.t\[Rule] x;
*)
Block[{t},
PolynomialerAusdruckInvP=Fit[DatenNeu,{t^3,t^5,t^7},t]+t;
PolynomFunktionInvP=Function[t,Evaluate[PolynomialerAusdruckInvP] ];
];
PolynomFunktionNormiertInvP=Function[t,Evaluate[Expand[N[(1/HalbeBildDiagonalenLaenge)*PolynomFunktionInvP[HalbeBildDiagonalenLaenge*t]]]]];

Polynome={PolynomFunktionInvP[x],PolynomFunktionNormiertInvP[x]};
Return[Polynome];
];


(* Funktion: Korrigiert die detektierten Eckpunkte mit dem angegebenen Polynom und Verzeichnungszentrum*)
(* Ben\[ODoubleDot]tigt: Hauptpunkt, Verzeichnungszentrum, indizierte Eckpunkte*)
(* Liefert: korrigierte Eckpunkteliste *)
EckPunktKorrektur[HP_,Polynom_,EckPunkteIndex_]:=Module[{EckPKorrigiert={},EckPunkte,PolynomTemp,PolyFunkTemp,i},
EckPunkte=EckPunkteIndex;
For[i=1,i<=Length[EckPunkte],i++,
PolynomTemp=Polynom[[1]];
PolyFunkTemp[t_]:=PolynomTemp/. x->t;
AppendTo[EckPKorrigiert,{((EckPunkte[[i,1]]-HP) *(PolyFunkTemp[Norm[EckPunkte[[i,1]]-HP]]/Norm[EckPunkte[[i,1]]-HP]))+HP,EckPunkte[[i,2]]}];
];
Return[EckPKorrigiert];
];


(* Funktion: Korrigiert die detektierten Eckpunkte mit dem angegebenen,normierten Polynom und Verzeichnungszentrum*)
(* Ben\[ODoubleDot]tigt: Hauptpunkt, normiertes Verzeichnungszentrum, indizierte Eckpunkte*)
(* Liefert: korrigierte Eckpunkteliste *)
EckPunktKorrekturNormiert[HP_,Polynom_,EckPunkteIndex_]:=Module[{EckPKorrigiert={},EckPunkte,PolynomTemp,PolyFunkTemp,i,EckpunkteTemp,NormFaktor},
EckPunkte=EckPunkteIndex;
NormFaktor=((Sqrt[BildHoehe^2+BildBreite^2])/2);
For[i=1,i<=Length[EckPunkte],i++,
PolynomTemp=Polynom[[2]];
PolyFunkTemp[t_]:=PolynomTemp/. x->t;
AppendTo[EckPKorrigiert,{((EckPunkte[[i,1]]-HP) *(PolyFunkTemp[Norm[EckPunkte[[i,1]]-HP]/NormFaktor]*NormFaktor/Norm[EckPunkte[[i,1]]-HP]))+HP,EckPunkte[[i,2]]}];
];
Return[EckPKorrigiert];
];



ImportDataAnalyze[SDSampleGroesse_,StartPunkt_,Bereich_,Schrittweite_]:=Module[{ErgebnisListe1={},ErgebnisListe2={},Sigma,SigmaVon=0,SigmaBis=0.4,SigmaSchrittweite=0.05,Anzahl=20,BildTemp={},BildName,Schritt1,Schritt2,DurchschnittsListe={},Auswertungsliste={},i,j,HPMittellaenge=0,MittelSchritt,Bildname,HPgemittelt,SDistgemittelt,SchrittMittel,SchrittOpti,BildKorr,BildkorrigiertOpti,BildkorrigiertMittel,PunkteOpti,StartPunktOpti,IndexPunkteOpti,FehlerOpti,PunkteMittel,StartPunktMittel,IndexPunkteMittel,FehlerMittel,PunktePreKorr,StartPunktPreKorr,IndexPunktePreKorr,FehlerPreKorr},
BildKorr=Import["107_149_K108_P2_Sigma_0.00_001.bmp","Image",Path-> "C:\\Users\\Philipp Hafen\\Documents\\P2\\K108\\107_149\\"];
For[Sigma=SigmaVon,Sigma<=SigmaBis,Sigma+=SigmaSchrittweite,
For[i=1,i<=Anzahl,i++,
BildName="107_149_K108_P2_Sigma_"<>ToString[NumberForm[Sigma,{2,2}]]<>"_"<>ToString[NumberForm[i,2,NumberPadding->{"0","0"}]]<>".bmp";
BildTemp=Import[BildName,"Image",Path-> "C:\\Users\\Philipp Hafen\\Documents\\P2\\K108\\107_149\\"];
Schritt1=AnalyzeDistortionBruteForce[BildTemp,StartPunkt,Bereich,Schrittweite,SDSampleGroesse][[1]];
Schritt2=AnalyzeDistortionBruteForce[BildTemp,Schritt1[[1]],{10,10},1,SDSampleGroesse][[1]];

AppendTo[ErgebnisListe1,Schritt1];
AppendTo[ErgebnisListe2,Schritt2];
writeLog[ToString[Schritt2]];
AppendTo[DurchschnittsListe,Schritt2];
If[i==Anzahl,
Bildname="107_149_K108_P2_Sigma_"<>ToString[NumberForm[Sigma,{2,2}]];
HPgemittelt=N[Mean[DurchschnittsListe[[All,1]]]];
SDistgemittelt=N[Mean[DurchschnittsListe[[All,3]]]];
For[j=1,j<= Length[DurchschnittsListe],j++,
HPMittellaenge+=Norm[HPgemittelt-DurchschnittsListe[[j,1]]];
];
HPMittellaenge=HPMittellaenge/Length[DurchschnittsListe];
writeLog["Sigma: "<>ToString[Sigma]<>" Bildname: "<>ToString[Bildname]];
SchrittOpti= Sort[DurchschnittsListe,#1[[4]]<#2[[4]]&][[1]];
SchrittMittel=AnalyzeDistortionBruteForce[BildTemp,HPgemittelt,{0,0},1,SDSampleGroesse][[1]];

BildkorrigiertOpti=BildKorrektur[BildKorr,SchrittOpti[[1]],SchrittOpti[[2,1]],0];
BildkorrigiertMittel=BildKorrektur[BildKorr,SchrittMittel[[1]],SchrittMittel[[2,1]],0];

PunkteOpti=FindPoints[BildkorrigiertOpti];
StartPunktOpti=FindStartPoint[PunkteOpti];
IndexPunkteOpti=Indizierung[PunkteOpti,StartPunktOpti, SchrittOpti[[3]]];
FehlerOpti=AequidistanzFehler[IndexPunkteOpti][[2]];

PunkteMittel=FindPoints[BildkorrigiertMittel];
StartPunktMittel=FindStartPoint[PunkteMittel];
IndexPunkteMittel=Indizierung[PunkteMittel,StartPunktMittel, SchrittMittel[[3]]];
FehlerMittel=AequidistanzFehler[IndexPunkteMittel][[2]];

PunktePreKorr=FindPoints[BildTemp];
StartPunktPreKorr=FindStartPoint[PunktePreKorr];
IndexPunktePreKorr=Indizierung[PunktePreKorr,StartPunktPreKorr, Schritt2[[3]]];
FehlerPreKorr=AequidistanzFehler[IndexPunktePreKorr][[2]];

AppendTo[Auswertungsliste,{Bildname,Sigma,SchrittOpti[[1]],HPgemittelt,HPMittellaenge,SchrittOpti[[2,2]],SchrittMittel[[2,2]],SDistgemittelt,FehlerMittel,FehlerOpti,FehlerPreKorr}];
writeLog[ToString[{Bildname,Sigma,SchrittOpti[[1]],HPgemittelt,HPMittellaenge,SchrittOpti[[2,2]],SchrittMittel[[2,2]],SDistgemittelt,FehlerMittel,FehlerOpti,FehlerPreKorr}]];
HPMittellaenge=0;
DurchschnittsListe={};
writeLog["Sigma: "<>ToString[Sigma]<>", i: "<>ToString[i]];
];
];
];
AppendTo[ErgebnisListe2,Auswertungsliste];
Return[ErgebnisListe2];
];

(*Options[AnalyzeDistortionBruteForce]={KF\[Rule]31};*)
AnalyzeDistortionBruteForce[TestBild_,InitialPunkt_,Bereich_,Schrittweite_,SDSampleGroesse_, Punkte_:{},KF_:31, MittelOderMinMax_:2]:=Module[{StartZeitFindPoints,Fortschritt,PunkteSample,SollDistanzen,SollDistanzenInit,StartPunkt,SollDistanz,SollDistanzInit,i,j,SDSampleDim,SDSample,Abstaende,AbstaendeBereinigt,AbstaendeSD,IndexPunkte,SollGitter,SollIstListe,SollIstAbstaende,PolynomListe={},PolynomTemp,PolynomKorTemp,FehlerTemp,Ergebnis, LokalePunkte},
StartZeitBruteForce=TimeUsed[];
writeLog["Beginn des Moduls AnalyzeDistortionBruteForce"];
If [Length[Dimensions[ImageData[TestBild]]]==2,
{BildHoehe,BildBreite}=Dimensions[ImageData[TestBild]];,
{BildHoehe,BildBreite, BildTiefe}=Dimensions[ImageData[TestBild]];
];
If[Length[Punkte]== 0,
StartZeitFindPoints=TimeUsed[];
writeLog["Beginn der Lokalisierung der Schachbretteckpunkte."];
LokalePunkte=FindPoints[TestBild, KF];
writeLog["Die Routine FindPoints hat "<>ToString[Length[LokalePunkte]] <>" Eckpunkte lokalisiert."];
writeLog["Die Routine FindPoints ben\[ODoubleDot]tigte "<>ToString[TimeUsed[]- StartZeitFindPoints]<>" Sekunden."];
PunktListeBildKoordinaten={#[[2]],#[[1]]}&/@LokalePunkte;
PunktListeStandardKoordinaten=Map[BildKoordinatenZuStandardKoordinaten,PunktListeBildKoordinaten];
writeLog[Graphics[Show[TestBild, ListPlot[PunktListeStandardKoordinaten],ImageSize->Medium]]];
,
LokalePunkte = Punkte;
];

If[Length[LokalePunkte]>30,
SollDistanzenInit=AbstandsSuche[LokalePunkte,SampleSizing[SDSampleGroesse,{4,4},LokalePunkte],SDSampleGroesse];
StartPunkt=FindStartPoint[LokalePunkte];
SollDistanzInit=IterativeRefinementSollDistanz[SollDistanzenInit,1][[1,2]];
IndexPunkte=Indizierung[LokalePunkte,StartPunkt, SollDistanzInit];
StartZeitBruteForce=TimeUsed[];
For[i=-Bereich[[1]]/2,i<= Bereich[[1]]/2,i+=Schrittweite,
For[j=-Bereich[[2]]/2,j<= Bereich[[2]]/2,j+=Schrittweite,
SDSampleDim=SampleSizingPunkt[SDSampleGroesse,{4,3},LokalePunkte,{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j}];
SDSample=SamplePoints[LokalePunkte,SDSampleDim,{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j}];
Abstaende=AllDistances[SDSample];
AbstaendeBereinigt=IterativeRefinementSollDistanzEinzelPunkt[Abstaende];
If[Length[AbstaendeBereinigt]<SDSampleGroesse,
SollDistanz=Mean[AbstaendeBereinigt];
,
AbstaendeSD=FlattenAt[{{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j},firstBin[AbstaendeBereinigt,Round[SDSampleGroesse/2]]},2];
SollDistanz=AbstaendeSD[[2]];

];
SollGitter=TargetGrid[StartPunkt,SollDistanz,IndexPunkte];
SollIstListe=IstSollGitter[SollGitter,IndexPunkte];
SollIstAbstaende=N[IstSollDistanzen[SollIstListe,{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j}]];
PolynomTemp=CalculateInversePolynom[SollIstAbstaende];
PolynomKorTemp=CalculatePolynom[SollIstAbstaende];
If[MittelOderMinMax == 1,FehlerTemp=AequidistanzFehler[EckPunktKorrektur[{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j},PolynomTemp,SollIstListe[[All,{2,3}]]]][[1]];
,
FehlerTemp=AequidistanzFehler[EckPunktKorrektur[{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j},PolynomTemp,SollIstListe[[All,{2,3}]]]][[2]];
];

AppendTo[PolynomListe,{{InitialPunkt[[1]]+i,InitialPunkt[[2]]+j},PolynomKorTemp,SollDistanz,FehlerTemp,Length[LokalePunkte],Length[IndexPunkte]}];
FehlerTemp=0;

]; (* Ende For (j) *)

tIntermediate=TimeUsed[];
Fortschritt=N[100*(i+1+Bereich[[1]]/2)/(Bereich[[1]]+1),3];
AnzeigeFortschritt=True;
If[AnzeigeFortschritt==True,
writeStatus["AnalyzeDistortionBruteForce",Fortschritt,StartZeitBruteForce,tIntermediate],
Null
];
];(* Ende For (i) *)

Ergebnis=Sort[PolynomListe,#1[[4]]<#2[[4]]&];
,
Ergebnis={{{-1,-1},{-1,-1},-1,-1,-1,-1},{{-1,-1},{-1,-1},-1,-1,-1,-1}};
];
Return[Ergebnis];
];


KorrekturAnalyse[TestBild_,ReferenzBild_,InitialPunkt_,Bereich_,Schrittweite_,SDSampleGroesse_,BildName_]:=Module[{Ergebnis,Punkte,Schritt1,SollDistanzenInit,SollDistanzInit,StartPunkt,IndexPunkte,FehlerMittel,BildKorrigiert},
If [Length[Dimensions[ImageData[TestBild]]]==2,
{BildHoehe,BildBreite}=Dimensions[ImageData[TestBild]];,
{BildHoehe,BildBreite, BildTiefe}=Dimensions[ImageData[TestBild]];
];

Schritt1=AnalyzeDistortionBruteForce[TestBild,InitialPunkt,Bereich,Schrittweite,SDSampleGroesse][[1]];
Ergebnis=AnalyzeDistortionBruteForce[TestBild,Schritt1[[1]],{10,10},1,SDSampleGroesse][[1]];

BildKorrigiert=BildKorrektur[ReferenzBild,Ergebnis[[1]],Ergebnis[[2,1]],0];
Export[BildName,BildKorrigiert,"TIFF"];
Punkte=FindPoints[BildKorrigiert];
SollDistanzenInit=AbstandsSuche[Punkte,SampleSizing[SDSampleGroesse,{4,4},Punkte],SDSampleGroesse];
SollDistanzInit=IterativeRefinementSollDistanz[SollDistanzenInit,1][[1,2]];
StartPunkt=FindStartPoint[Punkte];
IndexPunkte=Indizierung[Punkte,StartPunkt, SollDistanzInit];
AequidistanzFehler[IndexPunkte][[2]];
writeLog[ToString[AequidistanzFehler[IndexPunkte][[2]]]];
Return[{FehlerMittel=AequidistanzFehler[IndexPunkte][[2]],Ergebnis[[1]]}];
];

QualitaetsAnalyse[TestBild_,SDSampleGroesse_]:=Module[{Ergebnis,Punkte,SollDistanzenInit,SollDistanzInit,StartPunkt,IndexPunkte,FehlerMittel},
If [Length[Dimensions[ImageData[TestBild]]]==2,
{BildHoehe,BildBreite}=Dimensions[ImageData[TestBild]];,
{BildHoehe,BildBreite, BildTiefe}=Dimensions[ImageData[TestBild]];
];

Punkte=FindPoints[TestBild];
SollDistanzenInit=AbstandsSuche[Punkte,SampleSizing[SDSampleGroesse,{4,4},Punkte],SDSampleGroesse];
SollDistanzInit=IterativeRefinementSollDistanz[SollDistanzenInit,1][[1,2]];
StartPunkt=FindStartPoint[Punkte];
IndexPunkte=Indizierung[Punkte,StartPunkt, SollDistanzInit];
(*FehlerMittel=AequidistanzFehler[IndexPunkte][[2]]*)
Return[AequidistanzFehler[IndexPunkte]];
];

DistortionAnalyzerSimple[TestBild_]:=Module[{Schritt1,Schritt2,StartPunkt,Bereich,Schrittweite,SDSampleGroesse, StartZeitLokal, Punkte},
StartZeitLokal=TimeUsed[];
If [Length[Dimensions[ImageData[TestBild]]]==2,
{BildHoehe,BildBreite}=Dimensions[ImageData[TestBild]];,
{BildHoehe,BildBreite, BildTiefe}=Dimensions[ImageData[TestBild]];
];
StartPunkt={BildBreite/2,BildHoehe/2};
Bereich={100,100};
Schrittweite=10;
SDSampleGroesse=10;
writeLog["Beginn der Lokalisierung der Schachbretteckpunkte."];
Punkte=FindPoints[TestBild];
writeLog[ToString["Die Routine FindPoints hat "<>ToString[Length[Punkte]]<>" Eckpunkte lokalisiert."]];
writeLog[ToString["Die Routine FindPoints ben\[ODoubleDot]tigte "<>ToString[TimeUsed[]- StartZeitLokal]<>" Sekunden."]];
Schritt1=AnalyzeDistortionBruteForce[TestBild,StartPunkt,Bereich,Schrittweite,SDSampleGroesse,Punkte][[1]];
Schritt2=AnalyzeDistortionBruteForce[TestBild,Schritt1[[1]],{10,10},1,SDSampleGroesse, Punkte][[1]];
writeLog["Ergebnis: "<>ToString[Schritt2]];
writeLog["Insgesamt ben\[ODoubleDot]tigte Laufzeit: "<>ToString[ TimeUsed[]-StartZeitLokal]<> " Sekunden, d.h. rund "<> ToString[Quotient[ Round[TimeUsed[]-StartZeitLokal],60]]<> " Minuten "<> ToString[Mod[Round[TimeUsed[]-StartZeitLokal],60]]<> " Sekunden."];

Return[Schritt2];
];

DistortionAnalyzerComplex[TestBild_,StartPunkt_,Bereich_,Schrittweite_,SDSampleGroesse_,EPa_:31, MittelOderMinMax_:2,Punkte_:{}]:=Module[{Schritt1,Schritt2,StartZeitLokal, LokalePunkte, StartZeitFindPoints},
StartZeitLokal=TimeUsed[];
(*writeLog["Start DistortionAnalyzerComplex"];*)

If[Length[Punkte]== 0,
StartZeitFindPoints=TimeUsed[];
writeLog["Beginn der Lokalisierung der Schachbretteckpunkte."];
LokalePunkte=FindPoints[TestBild, EPa];
writeLog["Die Routine FindPoints hat "<>ToString[Length[LokalePunkte]] <>" Eckpunkte lokalisiert."];
writeLog["Die Routine FindPoints ben\[ODoubleDot]tigte "<>ToString[TimeUsed[]- StartZeitFindPoints]<>" Sekunden."];
PunktListeBildKoordinaten={#[[2]],#[[1]]}&/@LokalePunkte;
PunktListeStandardKoordinaten=Map[BildKoordinatenZuStandardKoordinaten,PunktListeBildKoordinaten];
writeLog[Graphics[Show[TestBild, ListPlot[PunktListeStandardKoordinaten],ImageSize->Medium]]];
,
LokalePunkte = Punkte;
];


Schritt1=AnalyzeDistortionBruteForce[TestBild,StartPunkt,Bereich,Schrittweite,SDSampleGroesse,LokalePunkte, EP = EPa, MittelOderMinMax][[1]];
Schritt2=AnalyzeDistortionBruteForce[TestBild,Schritt1[[1]],{10,10},1,SDSampleGroesse,LokalePunkte, EP=EPa, MittelOderMinMax][[1]];
Return[Schritt2];
];

